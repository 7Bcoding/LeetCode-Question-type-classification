class Solution:
    def numOfSubarrays(self, arr):
        """
        :type arr: List[int]
        :rtype: int
        """
        # 解法：前缀和 + 数学
        #   这道题要求返回和为奇数的子数组数目。为了快速计算任意子数组的和，可以通过维护前缀和的方式。这道题只需要知道每个子数组的和的奇偶性，
        # 不需要知道子数组的和的具体值，因此不需要维护每一个前缀和，只需要维护奇数前缀和的数量与偶数前缀和的数量。
        #   分别使用 odd 和 even 表示奇数前缀和的数量与偶数前缀和的数量。初始时，odd=0，even=1，因为空的前缀的和是 0，也是偶数前缀和。
        # 遍历数组 arr 并计算前缀和。对于下标 i 的位置的前缀和（即arr[0]+arr[1]+…+arr[i]），根据奇偶性进行如下操作：
        # 1. 当下标 i 的位置的前缀和是偶数时，如果下标 j 满足 j < i 且下标 j 的位置的前缀和是奇数，则从下标 j+1 到下标 i 的子数组的和是奇数，
        # 因此，以下标 i 结尾的子数组中，和为奇数的子数组的数量即为奇数前缀和的数量odd；
        # 2. 当下标 i 的位置的前缀和是奇数时，如果下标 j 满足 j < i 且下标 j 的位置的前缀和是偶数，则从下标 j+1 到下标 i 的子数组的和是奇数，
        # 因此，以下标 i 结尾的子数组中，和为奇数的子数组的数量即为偶数前缀和的数量 even。
        # 上述下标 jj 的最小可能取值为 -1−1，当 j=-1j=−1 时表示下标 jj 的位置的前缀为空。
        #   在更新和为奇数的子数组数量之后，需要根据下标 i 的位置的前缀和的奇偶性更新 odd 或 even 的值。如果前缀和是奇数，则 odd 的值加 1；如果
        # 前缀和是偶数，则 even 的值加 1。

        MODULO = 10 ** 9 + 7
        odd, even = 0, 1
        subarrays = 0
        total = 0

        for x in arr:
            total += x
            subarrays += (odd if total % 2 == 0 else even)
            if total % 2 == 0:
                even += 1
            else:
                odd += 1

        return subarrays % MODULO

