class Solution(object):
    def trailingZeroes(self, n):
        """
        :type n: int
        :rtype: int
        """
        # 解法：计算因子5
        # 与计算阶乘方法不同，我们可以认识到阶乘末尾的每个 0 表示乘以 10。
        # 那么，我们在计算 n! 时乘以 10 的次数是多少？两个数字 a 和 b 相乘。例如，要执行 42⋅75=3150，可以重写如下：
        # 42 = 2 * 3 * 7
        # 75 = 3 * 5 * 5
        # 42 * 75 = 2 * 3 * 7 * 3 * 5 * 5
        # 现在，为了确定最后有多少个零，我们应该看有多少对 2 和 5 的因子。在上面的例子中，我们有一对 2 和 5 的因子。
        # 那么，这和阶乘有什么关系呢？在一个阶乘中，我们把所有 1 和 nn 之间的数相乘，这和把所有 1 和 nn 之间所有数字的因子相乘是一样的。
        # 例如，如果 n=16 ，我们需要查看 1 到 16 之间所有数字的因子。我们只对 2 和 5 有兴趣。包含 5 因子的数字是 5，10，15，
        # 包含因子 2 的数字是 2、4、6、8、10、12、14、16。因为只三个完整的对，因此 16! 后有三个零。
        # 这可以解决大部分情况，但是有的数字存在一个以上的因子。例如，若 i = 25，那么我们只做了 fives += 1。但是我们应该 fives += 2，
        # 因为 25 有两个因子 5。
        # 因此，我们需要计算每个数字中的因子 5。我们可以使用一个循环而不是 if 语句，我们若有因子 5 将数字除以 5。如果还有剩余的因子 5，则将重复步骤。
        # 首先，我们可以注意到因子 2 数总是比因子 5 大。为什么？因为每四个数字算作额外的因子 2，但是只有每 25 个数字算作额外的因子 5。
        # 因此我们可以删除计算因子 2 的过程，我们可以做最后一个优化。在上面的算法中，我们分析了从 11 到 nn 的每个数字。但是只有 5, 10, 15, 20, 25, 30,
        # ... 等等 至少有一个因子 55。所以，ww偶们不必一步一步的往上迭代，可以五步的往上迭代

        zero_count = 0
        for i in range(5, n + 1, 5):
            power_of_5 = 5
            while i % power_of_5 == 0:
                zero_count += 1
                power_of_5 *= 5

        return zero_count

