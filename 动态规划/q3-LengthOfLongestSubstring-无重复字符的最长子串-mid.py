class Solution(object):
    def lengthOfLongestSubstring(self, s):
        """
        :type s: str
        :rtype: int
        """
        # 解法：动态规划
        # 1. 状态的定义
        # dp[i]：以 s[i] 结尾的最长不重复子串的长度
        # 2. 推导状态转移方程
        # 这里我们尝试推导 dp[i] 与 dp[i - 1] 的关系，那当然要看 s[i] 啦，如果 s[i] 在滑动窗口内没有出现过，
        # 那么 s[i] 就可以出现在 dp[i - 1] 表示的那个“最长不重复子串”的后面，表示一个更长的“最长不重复子串”，
        # 此时 dp[i] = dp[i - 1] + 1
        # s[i] 之前有没有出现过”这件事情，我们恐怕还得借助“哈希表”或者数组。下面就要考虑 s[i] 在滑动窗口内出现
        # 过，一个比较容易想到的情况是，如果 dp[i] 特别短，它表示的“最长不重复子串”都够不着 s[i] 之前出现到的那个位置。
        # 情况就和上面一样：s[i] 也可以出现在 dp[i - 1] 表示的那个“最长不重复子串”的后面，表示一个更长的“最长不重复子串”，
        # 此时 dp[i] = dp[i - 1] + 1。
        # 3. 边界条件：
        # dp[i - 1] 表示的那个“最长不重复子串”的左边界刚刚好够到“s[i] 之前出现过的位置”，即 dp[i - 1] >= i - s[i] 之前
        # 出现过的位置，此时 dp[i] 就只能是当前位置和“s[i] 之前出现过的位置”这两个位置确定的那个“不重复子串”的长度

        size = len(s)
        # 特判
        if size < 2:
            return size

        # dp[i] 表示以 s[i] 结尾的最长不重复子串的长度
        # 因为自己肯定是不重复子串，所以初始值设置为 1
        dp = [1 for _ in range(size)]
        d = dict()

        d[s[0]] = 0
        # 因为要考虑 dp[i - 1]，索引得从 1 开始，故 d[s[0]] = 0 得先写上
        for i in range(1, size):
            if s[i] in d:
                if dp[i - 1] >= i - d[s[i]]:
                    dp[i] = i - d[s[i]]
                else:
                    dp[i] = dp[i - 1] + 1
            else:
                dp[i] = dp[i - 1] + 1
            # 设置字符与索引键值对
            d[s[i]] = i
        # 最后拉通看一遍最大值
        return max(dp)
