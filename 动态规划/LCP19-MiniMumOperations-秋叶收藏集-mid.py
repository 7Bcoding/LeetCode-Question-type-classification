class Solution(object):
    def minimumOperations(self, leaves):
        """
        :type leaves: str
        :rtype: int
        """
        # 解法：动态规划（状态dp）
        # 从左到右遍历所有叶子，要满足题目要求只会出现三种状态：
        # 1. 红...            ———— 纯红色状态下         遇到 红色 或 黄色
        # 2. 红...黄...       ———— 纯红+纯黄状态下      遇到 红色 或 黄色
        # 3. 红...黄...红...  ———— 纯红+纯黄+纯红状态下  遇到 红色 或 黄色
        # 操作数发生增加的情况，只有5种：
        # a. 1 -> 1 纯红维持自身状态 dp[0][i]:
        #    遇到黄色叶子变红色，操作数+1   —— dp[0][i] + 1 ；
        #    遇到红色叶子保持不变          —— dp[0][i]
        # b. 1 -> 2 红到红黄 dp[1][i]:
        #    遇到红色叶子变黄色，操作数+1   —— dp[0][i] + 1 ；
        #    遇到黄色叶子保持不变          —— dp[0][i]
        # c. 2 -> 2 红黄维持自身状态 dp[1][i]:
        #    遇到红色叶子变黄色，操作数+1   —— dp[1][i-1] + 1 ；
        #    遇到黄色叶子保持不变          —— dp[1][i-1]
        # d. 2 -> 3 红黄到红黄红 dp[2][i]:
        #    遇到黄色叶子变红色，操作数+1   —— dp[1][i-1] + 1 ；
        #    遇到红色叶子保持不变          —— dp[1][i-1]
        # e. 3 -> 3 红黄红维持自身状态 dp[2][i]:
        #    遇到黄色叶子变红色，操作数+1 —— dp[2][i-1] + 1；
        #    遇到红色叶子保持不变 —— dp[2][i-1]

        n = len(leaves)
        dp = [[float('inf')] * n for _ in range(3)]
        for i in range(n):
            if i == 0:
                dp[0][i] = 0 if leaves[i] == 'r' else 1
                continue
            dp[0][i] = dp[0][i-1] + (leaves[i] == 'y')
            dp[1][i] = min(dp[1][i-1], dp[0][i-1]) + (leaves[i] == 'r')
            dp[2][i] = min(dp[2][i-1], dp[1][i-1]) + (leaves[i] == 'y')

        return dp[2][n-1]

