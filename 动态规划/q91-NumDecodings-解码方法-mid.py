class Solution(object):
    def numDecodings(self, s):
        """
        :type s: str
        :rtype: int
        """
        # 解法：动态规划
        # 1. 定义状态
        # 既然结尾的字符很重要，在定义状态的时候可以这样定义：dp[i]—— 以 s[i] 结尾的前缀子串有多少种解码方法。
        # 2. 推导状态转移方程
        # -- 如果 s[i] == '0' ，字符 s[i] 就不能单独解码，所以当 s[i] != '0' 时，dp[i] = dp[i - 1] * 1。
        # 说明：为了得到长度为 i + 1 的前缀子串的解码个数，需要先得到长度为 i 的解码个数，再对 s[i] 单独解码，
        # 这里分了两步，根据「分步计数原理」，用乘法。这里的 1 表示乘法单位，语义上表示 s[i] 只有 1 种编码。
        # -- 如果当前字符和它前一个字符，能够解码，即 10 <= int(s[i - 1..i]) <= 26，即 dp[i] += dp[i - 2] * 1
        # 说明：不同的解码方法，使用「加法」，理论依据是「分类计数的加法原理」，所以这里用 +=。
        # 注意：状态转移方程里出现了下标 i - 2，需要单独处理（如何单独处理，需要耐心调试）。
        # 3. 初始化
        # 如果首字符为 0 ，一定解码不了，可以直接返回 0，非零情况下，dp[0] = 1
        # 4. 考虑输出
        # 输出是 dp[len - 1]，符合原始问题。
        # 5. 考虑优化空间
        # 这里当前状态值与前面两个状态有关，因此可以使用三个变量滚动计算。但空间资源一般来说不紧张，不是优化的方向，故不考虑。

        if not s or s[0] == '0': return 0
        dp = [0] * len(s)
        dp[0] = 1
        for i in range(1, len(s)):
            if s[i] == s[i - 1] == '0': return 0
            if 0 <= int(s[i - 1:i + 1]) <= 26:
                if s[i] == '0':
                    dp[i] = 1 if i == 1 else dp[i - 2]
                elif s[i - 1] == '0':
                    dp[i] = dp[i - 1]
                else:
                    dp[i] = 2 if i == 1 else dp[i - 1] + dp[i - 2]
            else:
                if s[i] == '0': return 0
                dp[i] = dp[i - 1]
        return dp[len(s) - 1]